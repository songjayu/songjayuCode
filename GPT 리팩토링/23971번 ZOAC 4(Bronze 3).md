# 📝 거리두기 규칙을 지키면서 강의실 최대 수용 인원 계산

## ✅ 네 코드에서 구현된 내용

네 코드는 **거리두기 규칙을 지키면서 최대 몇 명을 배치할 수 있는지 계산하는 방식**으로 잘 구현되어 있어!  
아래와 같은 구조로 동작해.  

### 1️⃣ **각 행(`H`)에서 가능한 자리 개수 계산**

- `(N+1)`칸마다 한 명씩 앉을 수 있음  
- `H % (N+1) == 0`이면 정확히 `H // (N+1)`명이 앉을 수 있음  
- 그렇지 않으면 `+1`을 해서 나머지 공간까지 고려  

### 2️⃣ **각 열(`W`)에서도 같은 방식 적용**

- `(M+1)`칸마다 한 명씩 앉을 수 있음  
- `W % (M+1) == 0`이면 정확히 `W // (M+1)`명이 앉을 수 있음  
- 그렇지 않으면 `+1`을 해서 나머지 공간까지 고려  

### 3️⃣ **총 수용 가능 인원 계산**

- 위에서 구한 `max_H`와 `max_W`를 곱해서 전체 가능한 자리 개수를 구함  
- 최종적으로 `print(gross)`를 통해 결과 출력  

---

## 🔹 **네 코드**

```python
H, W, N, M = map(int, input().split())
max_H = 0
max_W = 0

if H % (N+1) == 0:
    max_H = (H // (N+1))
else:
    max_H = (H // (N+1)) + 1

if W % (M+1) == 0:
    max_W = (W // (M+1))
else:
    max_W = (W // (M+1)) + 1

gross = max_H * max_W
print(gross)
```

## ✨ 개선된 코드에서 변경된 내용

### ✅ **1. 불필요한 `if-else` 제거**

- `(H + N) // (N + 1)`을 쓰면 자동으로 올림 효과가 나서, 조건문 없이 같은 결과를 얻을 수 있음  
- `(W + M) // (M + 1)`도 동일한 방식 적용  

### ✅ **2. 변수 초기화 없이 바로 계산**

- `max_H = 0`, `max_W = 0` 같은 초기화가 불필요해서 제거  

### ✅ **3. 연산 최적화 (더 빠르고 간결한 계산)**

- 기존 코드는 `if`문을 써서 조건을 확인하지만, 개선된 코드는 **한 줄 연산으로 같은 결과를 빠르게 계산**  

---

## 🔹 **개선된 코드 (`math.ceil()` 없이 최적화)**

```python
H, W, N, M = map(int, input().split())

max_H = (H + N) // (N + 1)  # 세로로 앉을 수 있는 최대 인원
max_W = (W + M) // (M + 1)  # 가로로 앉을 수 있는 최대 인원

gross = max_H * max_W  # 전체 수용 가능 인원

print(gross)
```

\## 🚀 **개선된 코드 (`math.ceil()` 사용)** 

```python import math H, W, N, M = map(int, input().split()) max_H = math.ceil(H / (N + 1))  # 세로로 앉을 수 있는 최대 인원 max_W = math.ceil(W / (M + 1))  # 가로로 앉을 수 있는 최대 인원 gross = max_H * max_W  # 전체 수용 가능 인원 print(gross)

```

## ✅ **`ceil()`을 사용했을 때의 장점**

### 🎯 **1. 더 직관적인 의미 전달**

- `(H + N) // (N + 1)` 방식은 올림 처리가 자연스럽게 되지만, 처음 보는 사람이 이해하기 어려울 수 있어.  
- `math.ceil(H / (N + 1))`을 사용하면 **"H를 (N+1)로 나눠서 올림한 값"** 이라는 의미가 바로 보임.  

### 🎯 **2. 논리적으로 깔끔한 표현**

- **`ceil(x / y)`**는 `"x를 y로 나눈 후 올림"`을 의미하니까 **거리두기 규칙을 적용한 자리 배치를 계산할 때 직관적**이야.  

### 🎯 **3. 명확한 의도 전달**

- `(H + N) // (N + 1)`은 **"올림하려고 N을 더한다"**는 트릭을 사용한 것처럼 보일 수도 있음.  
- 반면, `math.ceil(H / (N + 1))`을 보면 **"우리는 올림을 원한다"**라는 의도가 더 뚜렷함.  

---

## ⏳ **`ceil()`을 쓰지 않는 버전과 비교**

| 방식                     | 코드             | 가독성                  | 성능                         |
| ------------------------ | ---------------- | ----------------------- | ---------------------------- |
| `math.ceil(H / (N + 1))` | `ceil()` 사용    | ✅ 더 명확함             | ❌ 약간 느림 (함수 호출 비용) |
| `(H + N) // (N + 1)`     | 정수 연산만 사용 | ❌ 덜 직관적일 수도 있음 | ✅ 빠름 (연산만 수행)         |

---

## 🎯 **결론**

- **가독성을 더 중요하게 생각하면 `ceil()`을 쓰는 게 좋고, 성능을 조금이라도 최적화하려면 정수 연산 방식**이 더 빠를 수도 있어.  
- 하지만 이 문제에서는 `H, W ≤ 50,000` 정도라서 성능 차이는 거의 없으니까 **`math.ceil()`을 쓰는 게 더 직관적이고 좋을 것 같아!** 😊  

---

네가 **가독성을 더 중요하게 생각한다면 `ceil()`을 사용한 버전이 더 좋은 선택**이야!  
어떤 방식이든 취향에 따라 선택하면 돼 😉 🚀  
